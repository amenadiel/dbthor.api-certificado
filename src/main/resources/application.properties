#Spring properties
spring.profiles.active=@activatedProperties@
spring.application.name=@profilePrefix@@artifactId@
spring.application.build.version=@project.version@
spring.application.build.number=@buildNumber@

#Database Connection
spring.datasource.url=@spring.datasource.url@
spring.datasource.username=@spring.datasource.username@
spring.datasource.password=@spring.datasource.password@

# Keep the connection alive if idle for a long time (needed in production)
spring.datasource.tomcat.test-while-idle=true
spring.datasource.tomcat.test-on-borrow=true
spring.datasource.tomcat.validation-query=SELECT 1
##IMPORTANTE PARA MANTENER EL POOL DE CONEXIONES
##CONECIONES INICIALES
spring.datasource.tomcat.initial-size=1
##MAXIMAS CONECCIONES QUE PUEDEN ESTARACTIVAS
spring.datasource.tomcat.max-active=20
##MAXIMAS CONECCIONES QUE SE MANTENIEN INACTIVAS
spring.datasource.tomcat.max-idle=2
spring.datasource.tomcat.min-idle=1
##Tiempo que espera antes de timeout en milisegundos  2 minutos
spring.datasource.tomcat.max-wait=120000

spring.datasource.tomcat.name=${spring.application.name}

# Show or not log for each sql query
spring.jpa.show-sql=false
spring.jpa.hibernate.ddl-auto=none
spring.jpa.hibernate.naming.strategy=org.hibernate.cfg.ImprovedNamingStrategy
#
# Use spring.jpa.properties.* for Hibernate native properties (the prefix is stripped before adding them to the entity manager)
# The SQL dialect makes Hibernate generate better SQL for the chosen database
#spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQL94Dialect
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect

# Swagger Config
swagger.info.title=@name@
swagger.info.description=@description@
swagger.info.groupName=@artifactId@
swagger.info.version=@project.version@-b@buildNumber@
swagger.info.license=DBThor
swagger.pathMapping=/
swagger.ui.webpage=swagger-ui.html

# Server
management.security.enabled=false
management.health.jms.enabled=true
spring.jmx.enabled=false

endpoints.info.enabled=true
endpoints.jmx.enabled=false
management.context-path=/management
info.build.version=@project.version@

# Logging
logging.file=@log.path@${spring.application.name}.log
logging.pattern.console=%clr{%d{yyyy-MM-dd HH:mm:ss.SSS}}{faint} %clr{%5p} %clr{---}{faint} %clr{[%15.15t]}{faint} %clr{%-40.40c{1.}}{cyan} %clr{:} %clr{%-35.35M}{magenta} %clr{:}{faint} %m%n${sys:%xwEx}
logging.pattern.file=%clr{%d{yyyy-MM-dd HH:mm:ss.SSS}}{faint} %clr{%5p} %clr{${sys:????}}{magenta} %clr{---}{faint} %clr{[%15.15t]}{faint} %clr{%-40.40c{1.}}{cyan} %clr{:} %clr{%-35.35M}{magenta} %clr{:}{faint} %m%n${sys:%xwEx}
logging.level.com.dbthor=debug

#RestFul Config
restful.timeout.connect=300000
restful.timeout.read=600000

#######################################################################################################################
#Database Schema Catalog (esto se debe configurar en la clase HibernateInterceptor.class para su corrcto uso)
#db.domain.certificado.schemaCatalog=dbthor_dte
db.domain.certificado.schemaCatalog=@db.dominio.certificado.catalogSchema@

#API DBThor
url.srv.base=@url.srv.base@
url.srv.persona.host=${url.srv.base}@url.srv.persona.path@
url.srv.dte.host=${url.srv.base}@url.srv.dte.path@

##API DBThor Persona
url.srv.persona.get=${url.srv.persona.host}/persona/{personaId}
url.srv.persona.buscar.get=${url.srv.persona.host}/persona/{tipo}/{identificador}
url.srv.persona.ident.buscar.get=${url.srv.persona.host}/identificacion

##API SII
url.srv.dte.sii.token.get=${url.srv.dte.host}/sii/getToken


